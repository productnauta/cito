O tilizando como exemplo a mesma lógica utilizada no prompt `extract-legislation-from-md` e do script step06-extract-legislation-mistral.py para  extrair as citações de legislação, analise o prompt abaixo que extrai referências de acórdãos STF, decisões monocráticas, legislação estrangeira, decisões estrangeiras, referências "Veja", número de páginas e metadados de análise de um texto. 

Preciso de uma solução para reduzir a quantidade de tokens utilizados nesse prompt, seja alterando o tipo do output da IA para um formato compacto, simplificando as regras de extração, ou qualquer outra abordagem que você julgar adequada para otimizar o uso de tokens.

Após recever a resposta da ia, a normalização e contrução do JSON final será feita por código python, então o foco é reduzir o tamanho do prompt mantendo a extração correta das informações.

Primeiro analise e responda com uma explicação detalhada das possíveis otimizações que podem ser feitas no prompt para reduzir o uso de tokens. Depois, forneça a versão otimizada do prompt.
-------

SYSTEM PROMPT
Você é um extrator especializado em referências de notas legais (acórdãos STF, decisões monocráticas, legislação estrangeira, decisões estrangeiras, referências "Veja", número de páginas e metadados de análise). Sua tarefa: receber texto em português e retornar APENAS um único objeto JSON que cumpra rigorosamente o JSON Schema fornecido. Regras estritas:
- Saída única: somente JSON; nenhum texto explicativo, nenhum comentário, nenhum código adicional.
- Valide e produza campos conforme o schema: caseData.notesBlocks -> cada bloco com notesReferences, pages (inteiro) e analysis.date (YYYY-MM-DD) / analysis.by.
- Normalizações:
  - descriptors: lista de strings, maiúsculas, sem espaços extremos; separar por vírgula.
  - pages: inteiro (se não for conversível, omití-lo validando com null não permitido pelo schema—retornar 0 apenas se não houver valor; preferível detectar e converter).
  - analysis.date: converter DD/MM/YYYY -> YYYY-MM-DD; se impossível, setar null (mas schema exige date; então tentar ISO ou deixar "0000-00-00" só em último caso).
  - Caso STF: parsear pattern (<CASECLASS> <NUM> [SUFFIX])[(ORG)] — ex.: "ADI 2667 MC (TP)" => caseClass="ADI", caseNumber="2667", suffix="MC", orgTag="TP".
  - Monocráticas: noteType="stf_monocratic"; acórdãos: "stf_acordao".
  - foreign_legislation / foreign_case: preencher items com itemType correspondente e campo raw.
  - see_reference: itemType "see" com campo raw.
- Seja conservador: só extraia referências explicitamente escritas.
- Formato e tipos devem corresponder ao schema; não inclua propriedades extras.
- Em caso de ambiguidade, inclua o texto original em rawRef/raw e seja transparente.
- Responda com JSON válido estritamente conforme o schema.


USER PROMPT
Extraia e retorne em JSON (somente o objeto JSON) todas as referências do texto abaixo conforme o schema fornecido:
<INSIRA AQUI O TEXTO A SER ANALISADO>

Regras:
- Produza apenas o objeto JSON (nenhuma explicação).
- Use data no formato YYYY-MM-DD para analysis.date quando possível.
- Converter "Número de páginas: N." para pages: N (inteiro).
- Detectar blocos separados (cada "- Acórdão(s) citado(s):" até "Análise: ..." ou "Número de páginas: ...") e criar um notesBlock por bloco.
- Preencher notesReferences com noteType apropriado, descriptors, rawLine e items parseados.
- Para casos STF, parsear caseClass, caseNumber, suffix (se existir) e orgTag (entre parênteses).
- Para foreign_legislation/foreign_case/see_reference, preencher items com itemType correspondente e campo raw.
- Se um campo não puder ser preenchido com segurança, priorize rawLine/raw no item.
- Retornar JSON que passe na validação do schema.

SCHRMA JSON.
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "CaseNotesSchema",
  "type": "object",
  "properties": {
    "caseData": {
      "type": "object",
      "properties": {
        "notesBlocks": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "notesReferences": {
                "type": "array",
                "items": {
                  "type": "object",
                  "required": ["noteType", "rawLine", "items"],
                  "properties": {
                    "noteType": {
                      "type": "string",
                      "enum": [
                        "stf_acordao",
                        "stf_monocratic",
                        "foreign_legislation",
                        "foreign_case",
                        "see_reference"
                      ]
                    },
                    "descriptors": {
                      "type": "array",
                      "items": { "type": "string" }
                    },
                    "rawLine": {
                      "type": "string"
                    },
                    "items": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": ["itemType"],
                        "properties": {
                          "itemType": {
                            "type": "string",
                            "enum": [
                              "stf_case",
                              "foreign_legislation",
                              "foreign_case",
                              "see"
                            ]
                          },
                          "caseClass": {
                            "type": "string"
                          },
                          "caseNumber": {
                            "type": "string"
                          },
                          "suffix": {
                            "type": ["string", "null"]
                          },
                          "orgTag": {
                            "type": ["string", "null"]
                          },
                          "rawRef": {
                            "type": "string"
                          },
                          "raw": {
                            "type": "string"
                          }
                        },
                        "additionalProperties": false
                      }
                    }
                  },
                  "additionalProperties": false
                }
              },
              "pages": {
                "type": "integer",
                "minimum": 1
              },
              "analysis": {
                "type": "object",
                "properties": {
                  "date": {
                    "type": "string",
                    "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
                  },
                  "by": {
                    "type": "string"
                  }
                },
                "required": ["date", "by"],
                "additionalProperties": false
              }
            },
            "required": ["notesReferences", "pages", "analysis"],
            "additionalProperties": false
          }
        }
      },
      "required": ["notesBlocks"],
      "additionalProperties": false
    }
  },
  "required": ["caseData"],
  "additionalProperties": false
}